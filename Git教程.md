# 本地Git

## 一、基础篇(循序渐进地介绍Git主要命令)

### git commit, git branch, git checkout, git merge, git rebase

3. 合并分支的方法

   + 切换到A分支下，用命令git merge B 即可吞并B分支

   + 切换到B分支下，用命令git rebase A 即可把B与A不同的提交复制到A的线性提交下，记住若想保持A与B一致，还得checkout A以及git rebase B； 实际上就是取出一系列的提交记录，“复制”他们，然后在另一个地方逐个地放下去。

     优势就是可以创造更线性的提交历史。如果只允许使用git rebase的话，代码库的提交历史将会变得异常清晰。



## 二、高级篇(要开始介绍Git的超棒特性了，快来吧！)

1. 分离head：

   head是啥？

   head是一个对当前检出记录的符号引用--也就是指向你正在其基础上进行工作的提交记录。

   head总是指向当前分支上最近一次提交记录。（大多数修改提交树的Git命令都是从改变head的指向开始的）

   head通常情况下是指向分支名的（如bugFix），在你提交时，改变了bugFix的状态，这一变化通过head变得可见。

   --------------------------------------------

   那么啥叫分离head呢？

   就是让其指向了某个具体的提交记录而不是分支名。

   假设有个提交记录为C1，则分离head指向C1的命令为

   git checkout C1

   

# 远程

## Push && Pull--Git远程仓库！

## 一、是时候分享你的代码了， 让编码变得社交化吧！

1. git clone

   远程仓库并不复杂，在如今的云计算盛行的世界很容易把远程仓库想象成一个富有魔力的东西，但实际上它们只是你的仓库在另一台计算机上的拷贝。你可以通过因特网与这台计算机通信--也就是增加或是获取提交记录。

   话虽如此，远程仓库却有一系列强大的特性

   + 首先也是最重要的点，远程仓库是一个强大的备份。
   + 还有就是，远程让代码社交化了！既然你的项目被托管到别的地方了，你的朋友可以更容易地为你的项目做贡献（或者pull最新的变更）

   现在用网站来对远程仓库进行可视化操作变得越发流行了（像github或phabricator），但远程仓库永远是这些工具的顶梁柱，因此理解其概念非常的重要！

   ---------------------

   从技术上，git clone命令在真实的环境下的作用是在本地创建一个远程仓库的拷贝（比如从github）。

   深入来看，git clone到底发生了什么？

   首先本地仓库多了个名为origin/master的分支，这种类型的分支就叫远程分支。有一些特殊属性。

   远程分支反映了远程仓库（在你上次和它通信时）的状态。这会有助于你理解本地的工作与公共工作的差别--这是你与别人分享工作成果前至关重要的一步。

   远程分支有一个特别的属性，在你检出时自动进入分离head状态（即head指向某条记录而不是分支名）。Git这么做是出于不能直接在这些分支上进行操作的原因，你必须在别的地方完成你的工作，（更新了远程分支之后）再用远程分享你的工作成果。    目的是为了方便观察本地和远程仓库的差别即你后来的提交！！！！！！

   远程分支有一个命名规范--格式是：

   远程仓库名/分支名

   而当你git clone某个仓库时，git已经帮你把远程仓库的名称设置为origin了。 

2. git fetch

   我们可以分享任何能被Git管理的更新（因此可以分享代码、文件、想法、情书等等）。

   git fetch做了什么？

   git fetch完成了仅有的但是很重要的两步：

   + 从远程仓库下载本地仓库中缺失的提交记录
   + 更新远程分支指针（如origin/master）

   git fetch实际上将本地仓库中的远程分支更新成了远程仓库相应分支最新的状态！！！！！！！

   上个命令我们说过，远程分支反映了远程仓库在你最后一次与他通信时的状态，git fetch就是你与远程仓库通信的方式了！PS：git fetch通常通过互联网（使用http://或git://协议）与远程仓库通信。

   git fetch不会做的事？

   它不会改变你本地仓库的状态。不会更新你的master分支，也不会修改你磁盘上的文件！！！

   理解这一点很重要，因为许多开发人员误以为执行了git fetch之后，他们本地仓库就与远程仓库同步了。它可能已经将进行这一操作所需的所有数据都下载了下来，但是并没有修改你本地的文件！！

   所以你可以将git fetch理解为单纯的下载操作！

3. git pull

   既然我们已经知道了如何用git fetch获取远程的数据，现在我们学习如何将这些变化更新到我们的工作中。

   由于先抓取更新再合并到本地分支这个流程很常用，因此Git提供了一个专门的命令来完成这两个操作。它就是git pull。

   git pull == git fetch + git merge

4. 模拟团队协作！

   如果你发现你的队友们在远程仓库上做了新的提交，该怎么办？

   1. git fetch获取远程更新
   2. git checkout切换到本地工作分支进行自己要做的工作
   3. 最后git merge 远程分支！！！

5. git push

   我们已经学过了如何从远程仓库获取最新更新并合并到本地的分支当中，可是我如何与大家分享我的成果呢？

   也就是说，在上一步中，git merge（或者直接git pull）之后怎么办呢？

   git push负责将你的变更上传到指定的远程仓库，并在远程仓库上合并你的新提交记录，一旦git push完成，你的朋友们就可以从这个远程仓库下载你分享的成果了！

   你也可以将git push想象成发布你成果的命令！

   PS：git push不带任何参数时的行为与Git的一个名为push.default的配置有关，它的默认值取决于你正使用的Git的版本。

6. 偏离的历史提交（注意与4的区别！！！）

   如果你周一clone了一个仓库，然后开始研发某个新功能，但你的同事与此同时修改了许多你要用到的API并且提交到了远程仓库，因此你的代码就变成了基于旧版的代码，与远程仓库最新的代码不匹配了！

   这种情况下，Git是不会允许你push变更的，实际上它会强制你先合并远程最新的代码，然后才能分享你的工作。

   如何解决这个问题呢？很简单，你需要做的就是使你的工作基于最新的远程分支。

   有很多方法做到这一点，不过

   1. 最直接的方法就是通过rebase调整你的工作。即用git fetch更新了本地仓库中的远程分支，然后用git rebase将我们的工作移动到最新的提交记录下，最后再用git push推送到远程仓库。

   2. 第二个方法就是4了先用git fetch更新了本地仓库中的远程分支，然后git merge 远程分支，最后git push

      所以，可以直接git pull + git push!!!

      而且，1.也可以简化：git pull --rebase == git fetch + git rebase然后再git push, 即git pull --rebase就是将我们的工作rebase到远程分支的最新提交记录！！！！

## 



## 关于origin和它的周边--Git远程仓库高级操作

## 做一名仁慈的独裁者一定会很有趣......

1. 推送主分支